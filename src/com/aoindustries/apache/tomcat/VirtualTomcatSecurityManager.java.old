/*
 * aocode-public - Reusable Java library of general tools with minimal external dependencies.
 * Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010  AO Industries, Inc.
 *     support@aoindustries.com
 *     7262 Bull Pen Cir
 *     Mobile, AL 36695
 *
 * This file is part of aocode-public.
 *
 * aocode-public is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * aocode-public is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with aocode-public.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.aoindustries.apache.tomcat;

import com.aoindustries.profiler.*;
import com.aoindustries.util.*;
import java.awt.*;
import java.io.*;
import java.lang.reflect.*;
import java.net.*;
import java.security.*;
import java.util.*;

/**
 * @author  AO Industries, Inc.
 */
final public class VirtualTomcatSecurityManager extends SecurityManager {

    /**
     * The maximum number of threads allowed in one site.
     */
    public static final int MAX_SITE_THREADS=30;

    private final String[] sites;

    private final int[] siteGroups;

    private final ThreadGroup[] threadGroups;

    private final VirtualTomcatOutputStream errorStream;

    private static final String[] allowedAccessClassInPackage={
        "sun.awt.motif.resources",
        "sun.beans.infos",
        "sun.io",
        "sun.net.smtp",
        "sun.reflect",
        "sun.security.jgss",
        "sun.security.provider",
        "sun.security.x509",
        "sun.text.resources",
        "sun.tools.javac",
        "sun.tools.javac.resources",
        "sun.tools.java",
        "sun.tools.util",
        "sun.tools.tree",
        "sun.tools.asm"
    };

    private static final String[] allowedLoadLibrary={
        "agent",
        "audio",
        "awt",
        "cmm",
        "dcpr",
        "dt_socket",
        "fontmanager",
        "hprof",
        "JdbcOdbc",
        "jdwp",
        "jpeg",
        "math",
        "mlib_image",
        "net",
        "zip"
    };

    private static RuntimePermission threadGroupPermission;

    VirtualTomcatSecurityManager(
	String[] sites,
	int[] siteGroups,
	ThreadGroup[] threadGroups,
        VirtualTomcatOutputStream errorStream
    ) {
        Profiler.startProfile(Profiler.INSTANTANEOUS, VirtualTomcatSecurityManager.class, "<init>(String[],int[],ThreadGroup[],VirtualTomcatOutputStream)", null);
        try {
            this.sites = sites;
            this.siteGroups = siteGroups;
            this.threadGroups = threadGroups;
            this.errorStream = errorStream;
        } finally {
            Profiler.endProfile(Profiler.INSTANTANEOUS);
        }
    }

    public void checkAccess(Thread thread) {
        Profiler.startProfile(Profiler.INSTANTANEOUS, VirtualTomcatSecurityManager.class, "checkAccess(Thread)", null);
        try {
            //super.checkAccess(thread);
            checkAccess(thread.getThreadGroup());
        } finally {
            Profiler.endProfile(Profiler.INSTANTANEOUS);
        }
    }

    public void checkAccess(ThreadGroup threadGroup) {
        Profiler.startProfile(Profiler.FAST, VirtualTomcatSecurityManager.class, "checkAccess(ThreadGroup)", null);
        try {
            if(threadGroup==null) throw new NullPointerException("thread group can't be null");
            try {
                if(threadGroupPermission==null) threadGroupPermission=new RuntimePermission("modifyThreadGroup");
                checkPermission(threadGroupPermission);
            } catch(SecurityException err) {
                Class[] classes=getClassContext();
                int len=classes.length;
                for(int c=1;c<len;c++) if(
                    classes[c]==VirtualTomcatSecurityManager.class
                    || classes[c]==VirtualTomcatOutputStream.class
                    || classes[c]==java.util.Random.class
                    || classes[c]==java.lang.Runtime.class
                    || classes[c]==java.awt.Component.class
                ) return;
                int thisIndex=getSiteIndex();

                // System threads can access any thread group
                if(thisIndex==-1) return;

                // Site threads must only access groups in their site
                int otherIndex=getSiteIndex(threadGroup);
                if(thisIndex!=otherIndex) logAndThrow(new SecurityException("Thread from site "+sites[thisIndex]+" trying to access ThreadGroup for site "+(otherIndex==-1?"-1 (System)":sites[otherIndex])));

                // Each site is limited to a certain number of threads
                ThreadGroup group=threadGroups[thisIndex];
                int activeCount=group.activeCount();
                if(activeCount>=MAX_SITE_THREADS) logAndThrow(new SecurityException("Only "+MAX_SITE_THREADS+" threads allowed for the "+sites[thisIndex]+" site, "+activeCount+" currently in use."));

                // The entire Java VM has a limit, too
            }
        } finally {
            Profiler.endProfile(Profiler.FAST);
        }
    }

    public void checkDelete(String file) {
        Profiler.startProfile(Profiler.INSTANTANEOUS, VirtualTomcatSecurityManager.class, "checkDelete(String)", null);
        try {
            checkFile(file, "delete");
        } finally {
            Profiler.endProfile(Profiler.INSTANTANEOUS);
        }
    }

    /**
     * The allowed files.
     */
    private void checkFile(String file, String actions) {
        Profiler.startProfile(Profiler.FAST, VirtualTomcatSecurityManager.class, "checkFile(String,String)", null);
        try {
            // Both of these are loaded when first needed
            Class[] classes=null;
            String wwwGroupDir=null;

            // Make in working directory if not an absolute path
            file=file.trim();
            if(file.charAt(0)!='/') file=(wwwGroupDir=System.getProperty("user.dir"))+'/'+file;

            // Is it read only
            boolean read="read".equals(actions);

            // Allow SecureRandom implementation to read /dev/random or /dev/urandom
            if(
                read
                && (
                    file.equals("/dev/random")
                    || file.equals("/dev/urandom")
                )
            ) {
                if(classes==null) classes=getClassContext();
                for(int c=0;c<classes.length;c++) {
                    if(classes[c].getName().equals("sun.security.provider.SecureRandom")) return;
                }
            }

            // Allow /etc/aoserv for aoserv configs
            if(file.equals("/etc/aoserv") || equalsAtStart(file, "/etc/aoserv/")) return;

            // Allow /home for sun 2D class
            if(equalsAtStart(file, "/home/")) {
                if(classes==null) classes=getClassContext();
                if(classes.length>3 && classes[3].getName().equals("sun.java2d.SunGraphicsEnvironment")) return;
            }

            // Allow /tmp for java.util.Random
            if(equalsAtStart(file, "/tmp")) {
                if(classes==null) classes=getClassContext();
                int len=classes.length;
                for(int c=0;c<len;c++) if(classes[c].getName().equals("java.util.Random")) return;
            }

            // Allow /usr but not /usr/tmp
            if(equalsAtStart(file, "/usr/") && !equalsAtStart(file, "/usr/tmp")) return;

            // Allow read only access to the wwwgroup classes
            if(read) {
                if(wwwGroupDir==null) wwwGroupDir=System.getProperty("user.dir");
                String classesDir=wwwGroupDir+"/classes";
                if(equalsAtStart(file, classesDir)) return;
            }

            // Iterate through all sites in the Java VM
            int index=getSiteIndex();
            if(wwwGroupDir==null) wwwGroupDir=System.getProperty("user.dir");
            int len=sites.length;
            int gid=siteGroups[index];
            for(int c=0;c<len;c++) {
                // Perform these checks for all sites that have the same group as the current
                if(siteGroups[c]==gid) {
                    // wwwDirectory for same group
                    String siteDir=VirtualTomcat.WWW_DIRECTORY+'/'+sites[c]+'/';
                    if(equalsAtStart(file, siteDir)) return;

                    // work directory for the same group
                    String workDir=wwwGroupDir+"/work/"+sites[c];
                    if(equalsAtStart(file, workDir)) return;
                }
            }

            // Not all errors will be logged
            boolean logError=true;

            // Read for everything but selected parts of wwwGroup
            int wwwGroupDirLen;
            if (
                read
                && equalsAtStart(file, wwwGroupDir)
                && !equalsInMiddle(file, "/bin/", wwwGroupDirLen=wwwGroupDir.length())
                && !equalsInMiddle(file, "/conf/", wwwGroupDirLen)
                && !equalsInMiddle(file, "/daemon/", wwwGroupDirLen)
                && !equalsInMiddle(file, "/var/", wwwGroupDirLen)
            ) return;

            // Allow read in other /www for tomcat only
            if(read) {
                if(equalsAtStart(file, VirtualTomcat.WWW_DIRECTORY+'/')) {
                    if(classes==null) classes=getClassContext();

                    // Accept if org.apache.jasper.compiler.SunJavaCompiler is somewhere in the list
                    // Or org.apache.tomcat.util.StringManager
                    len=classes.length;
                    for(int c=0;c<len;c++) if(
                        classes[c].getName().equals("org.apache.jasper.compiler.SunJavaCompiler")
                        || classes[c].getName().equals("org.apache.tomcat.util.StringManager")
                        || classes[c].getName().equals("org.apache.cocoon.processor.xsp.language.java.SunJavaCompiler")
                    ) return;

                    // Let the Tomcat logger read
                    if(classes.length>3 && classes[3].getName().equals("org.apache.tomcat.logging.Logger")) return;

                    // Do not log for these
                    if(
                        (classes.length>12 && classes[12].getName().equals("java.net.URLClassLoader"))
                        || (classes.length>11 && classes[11].getName().equals("javax.mail.Session"))
                        || (classes.length>7 && classes[7].getName().equals("java.net.URLClassLoader"))
                        || (classes.length>6 && classes[6].getName().equals("java.net.URLClassLoader"))
                        || (classes.length>5 && classes[5].getName().equals("java.net.URLClassLoader"))
                    ) logError=false;
                }
            } else if("write".equals(actions)) {
                if(equalsAtStart(file, VirtualTomcat.WWW_DIRECTORY+'/')) {
                    if(classes==null) classes=getClassContext();

                    // Allow any write for Tomcat logger
                    if(classes.length>5 && classes[5].getName().equals("org.apache.tomcat.logging.Logger")) return;
                }
            }

            SecurityException err=new SecurityException("File not allowed: filename="+file+" actions="+actions);
            if(logError) logAndThrow(err);
            throw err;
        } finally {
            Profiler.endProfile(Profiler.FAST);
        }
    }

    public void checkPermission(Permission perm) {
        Profiler.startProfile(Profiler.FAST, VirtualTomcatSecurityManager.class, "checkPermission(Permission)", null);
        try {
            if (perm instanceof FilePermission) {
                String actions = ((FilePermission) perm).getActions();
                if (actions.indexOf("execute") != -1) {
                    logAndThrow(new SecurityException("FilePermission: " + perm.getName()));
                } else
                    checkFile(perm.getName(), actions);
            } else if (perm instanceof RuntimePermission) {
                String name = perm.getName();
                if ("createSecurityManager".equals(name)
                    || equalsAtStart(name, "defineClassInPackage")
                    || "getClassLoader".equals(name)
                    || "getProtectionDomain".equals(name)
                    || "queuePrintJob".equals(name)
                    || "setIO".equals(name)
                    || "setSecurityManager".equals(name)) {
                    // Completely limited
                    logAndThrow(new SecurityException("RuntimePermission: " + name));
                } else if ("accessDeclaredMembers".equals(name) || "setFactory".equals(name)) {
                    // Not limited
                } else if ("exitVM".equals(name)) {
                    // Only Tomcat may close the Java VM
                    Class[] classes = getClassContext();
                    if (classes.length > 4 && classes[4] == org.apache.tomcat.startup.Tomcat.class) return;
                    logAndThrow(new SecurityException("RuntimePermission: " + name));
                } else if (equalsAtStart(name, "accessClassInPackage")) {
                    // Only selected packages allowed
                    int len = allowedAccessClassInPackage.length;
                    for(int c = 0; c < len; c++) if(equalsAtEnd(name, allowedAccessClassInPackage[c], 21)) return;
                    logAndThrow(new SecurityException("RuntimePermission: " + name));
                } else if ("setContextClassLoader".equals(name)) {
                    // Only Tomcat can do this
                    Class[] classes = getClassContext();
                    if (classes.length > 3 && classes[3] == org.apache.tomcat.core.ServletWrapper.class) return;
                    logAndThrow(new SecurityException("RuntimePermission should not be called here: " + name));
                } else if ("readFileDescriptor".equals(name)) {
                    // Only FileInputStream can do this
                    Class[] classes = getClassContext();
                    if (classes.length > 2 && classes[2] == java.io.FileInputStream.class) return;
                    logAndThrow(new SecurityException("RuntimePermission should not be called here: " + name));
                } else if ("writeFileDescriptor".equals(name)) {
                    // Only FileOutputStream can do this
                    Class[] classes = getClassContext();
                    if (classes.length > 2 && classes[2] == java.io.FileOutputStream.class) return;
                    logAndThrow(new SecurityException("RuntimePermission should not be called here: " + name));
                } else if ("createClassLoader".equals(name)) {
                    // Only Tomcat, Jasper, and Cocoon may create class loaders
                    Class[] classes = getClassContext();
                    for(int c=0;c<classes.length;c++) {
                        Class clazz=classes[c];
                        String classname=clazz.getName();
                        if(
                            classname.equals("org.apache.tomcat.loader.AdaptiveClassLoader")
                            || classname.equals("org.apache.jasper.runtime.JspLoader")
                            || classname.equals("org.apache.cocoon.processor.xsp.language.java.XSPClassLoader")
                            || classname.equals("org.apache.tomcat.util.SessionIdGenerator")
                            || classname.equals("org.apache.tomcat.util.xml.AddChild")
                            || classname.equals("org.apache.tomcat.util.xml.ObjectCreate")
                            || classname.equals("org.apache.tomcat.util.xml.SetParent")
                            || classname.equals("org.apache.tomcat.util.xml.XmlMapper")
                            || classname.equals("org.apache.xerces.validators.datatype.DatatypeValidatorFactoryImpl")
                        ) return;
                    }
                    logAndThrow(new SecurityException("RuntimePermission: " + name));
                } else if (equalsAtStart(name, "loadLibrary")) {
                    // Only selected libraries allowed
                    int len = allowedLoadLibrary.length;
                    for(int c = 0; c < len; c++) if(equalsAtEnd(name, allowedLoadLibrary[c], 12)) return;
                    logAndThrow(new SecurityException("RuntimePermission: Library not allowed: " + name));
                } else if ("modifyThread".equals(name) || "stopThread".equals(name) || "modifyThreadGroup".equals(name)) {
                    super.checkPermission(perm);
                } else if ("shutdownHooks".equals(name)) {
                    // allow all shutdown hooks
                    return;
                } else logAndThrow(new SecurityException("RuntimePermission: Unexpected name: " + name));
            } else if (perm instanceof NetPermission) {
                String name = perm.getName();
                if ("specifyStreamHandler".equals(name)) {
                    Class[] classes = getClassContext();
                    if(
                        (classes.length > 14 && classes[14] == java.util.ResourceBundle.class)
                        || (classes.length > 1 && classes[1] == java.net.URL.class)
                    ) return;
                    logAndThrow(new SecurityException("NetPermission: " + perm.getName()));
                } else logAndThrow(new SecurityException("NetPermission: " + perm.getName()));
            } else if (perm instanceof PropertyPermission) {
                // Any property may be set
                return;
                /*
                // Properties may only be set by trusted code
                PropertyPermission propertyPerm=(PropertyPermission)perm;
                if(propertyPerm.getActions().indexOf("write")!=-1) {
                Class[] classes=getClassContext();
                if(
                   (classes.length>6 && classes[6]==java.sql.DriverManager.class)
                   || (classes.length>5 && classes[5]==org.apache.tomcat.core.ServletWrapper.class)
                   || (classes.length>3 && classes[3]==org.apache.tomcat.startup.Tomcat.class)
                   || (classes.length>3 && classes[3].getName().equals("dmwayland.EmailManager"))
                   || (classes.length>4 && classes[4].getName().equals("java.util.GregorianCalendar"))
                   ) return;
                int len=classes.length;
                for(int c=0;c<len;c++) if(classes[c]==java.util.Random.class) return;
                logAndThrow(new SecurityException("PropertyPermission: "+perm.getName()));
                }
                */
            } else if (perm instanceof SocketPermission) {
                // There is no limit to socket permissions
            } else if (perm instanceof SecurityPermission) {
                // All Security permissions are allowed
            } else if (perm instanceof AWTPermission) {
                // All AWT permissions are allowed
            } else if (perm instanceof ReflectPermission) {
                // All reflect permissions allowed
            } else if (perm instanceof SerializablePermission) {
                // No serializing allowed
                logAndThrow(new SecurityException("SerializablePermission: " + perm.getName()));
            } else logAndThrow(new SecurityException("Unknown subclass if Permission: " + perm.getClass().getName()));
        } finally {
            Profiler.endProfile(Profiler.FAST);
        }
    }

    public void checkPermission(Permission perm, Object context) {
        Profiler.startProfile(Profiler.INSTANTANEOUS, VirtualTomcatSecurityManager.class, "checkPermission(Permission,Object)", null);
        try {
            checkPermission(perm);
        } finally {
            Profiler.endProfile(Profiler.INSTANTANEOUS);
        }
    }

    public void checkRead(String file) {
        Profiler.startProfile(Profiler.INSTANTANEOUS, VirtualTomcatSecurityManager.class, "checkRead(String)", null);
        try {
            checkFile(file, "read");
        } finally {
            Profiler.endProfile(Profiler.INSTANTANEOUS);
        }
    }

    public void checkRead(String file, Object context) {
        Profiler.startProfile(Profiler.INSTANTANEOUS, VirtualTomcatSecurityManager.class, "checkRead(String,Object)", null);
        try {
            checkFile(file, "read");
        } finally {
            Profiler.endProfile(Profiler.INSTANTANEOUS);
        }
    }

    public void checkWrite(String file) {
        Profiler.startProfile(Profiler.INSTANTANEOUS, VirtualTomcatSecurityManager.class, "checkWrite(String)", null);
        try {
            checkFile(file, "write");
        } finally {
            Profiler.endProfile(Profiler.INSTANTANEOUS);
        }
    }

    public static boolean equalsAtEnd(String line, String end, int pos) {
        Profiler.startProfile(Profiler.FAST, VirtualTomcatSecurityManager.class, "equalsAtEnd(String,String,int)", null);
        try {
            int endLen=end.length();
            if((endLen+pos)!=line.length()) return false;
            for(int c=0;c<endLen;c++) if(line.charAt(pos+c)!=end.charAt(c)) return false;
            return true;
        } finally {
            Profiler.endProfile(Profiler.FAST);
        }
    }

    public static boolean equalsAtStart(String line, String start) {
        Profiler.startProfile(Profiler.FAST, VirtualTomcatSecurityManager.class, "equalsAtStart(String,String)", null);
        try {
            int startLen=start.length();
            if(startLen>line.length()) return false;
            for(int c=0;c<startLen;c++) if(line.charAt(c)!=start.charAt(c)) return false;
            return true;
        } finally {
            Profiler.endProfile(Profiler.FAST);
        }
    }

    public static boolean equalsInMiddle(String line, String middle, int pos) {
        Profiler.startProfile(Profiler.FAST, VirtualTomcatSecurityManager.class, "equalsInMiddle(String,String,int)", null);
        try {
            int middleLen=middle.length();
            if((middleLen+pos)>line.length()) return false;
            for(int c=0;c<middleLen;c++) if(line.charAt(pos+c)!=middle.charAt(c)) return false;
            return true;
        } finally {
            Profiler.endProfile(Profiler.FAST);
        }
    }

    private int getSiteIndex() {
        Profiler.startProfile(Profiler.INSTANTANEOUS, VirtualTomcatSecurityManager.class, "getSiteIndex()", null);
        try {
            return getSiteIndex(Thread.currentThread().getThreadGroup());
        } finally {
            Profiler.endProfile(Profiler.INSTANTANEOUS);
        }
    }

    private int getSiteIndex(ThreadGroup TG) {
        Profiler.startProfile(Profiler.FAST, VirtualTomcatSecurityManager.class, "getSiteIndex(ThreadGroup)", null);
        try {
	// Search for a thread group match
	int len=threadGroups.length;
	while(TG!=null) {
	    for(int c=0;c<len;c++) if(threadGroups[c]==TG) return c;
	    TG=TG.getParent();
	}
        return -1;
        } finally {
            Profiler.endProfile(Profiler.FAST);
        }
    }

    /**
     * Logs an exception and then throws it.
     */
    private void logAndThrow(RuntimeException err) {
        Profiler.startProfile(Profiler.IO, VirtualTomcatSecurityManager.class, "logAndThrow(RuntimeException)", null);
        try {
            ErrorPrinter.printStackTraces(
                err,
                errorStream.masterOutput,
                new Object[] {"threadGroup="+sites[getSiteIndex()]}
            );
            throw err;
        } finally {
            Profiler.endProfile(Profiler.IO);
        }
    }
}